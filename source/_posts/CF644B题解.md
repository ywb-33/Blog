---
title: CF644B题解
date: 2024-08-03 19:44:48
tags: 题解
---
# CF644B（模拟）

## 题目大意：

给出 $N$ 个工作申请以及它们的开始时间、所需时间。当出现一个工作申请时，如果生产线空闲就会直接执行，等待队列少于 $b$ 个工作会把当前申请加到生产线中，否则会拒绝申请，求每个工作的完成时间。

## 思路分析：

很明显的一道模拟题。

因为这道题 $t_i \le 10^9$，所以我们直接枚举时间是会超时的。我们可以只维护一个等待序列，先把最开头的一个工作拿出来执行，再枚举当前所有开始时间小于当前时间的工作，如果队列中已有 $b$ 个元素就拒绝掉，否则将它加入队列中，一直重复直到队列为空或工作已经枚举完为止。

## 注意事项：

1. 如果当前队列为空，那么再开始执行工作前必须把下一个工作加到队列里（相当于直接执行）。

2. 由于本题 $t_i,d_i \le 10^9$，所以需要开 long long。

## 完整代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N=200005;
int n,b,p1=1,p2=0,q[N],d[N],t[N],p;
ll T,ans[N];
int main(){
	scanf("%d%d",&n,&b);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&t[i],&d[i]);
	T=(ll)(t[1]);
	while(1){
		if(p2<p1&&p<n)  q[++p2]=++p;//如果队列为空则直接取出下一个工作执行
		T=max(T,(ll)(t[q[p1]])),T+=(ll)(d[q[p1]]),ans[q[p1]]=T,p1++;//执行当前队列开头的工作
		while(p<n&&(ll)(t[p+1])<T){
			if(p2-p1+1<b)  q[++p2]=++p;//将工作加到队列中
			else  ans[++p]=-1;//拒绝当前工作
		}
		if(p==n&&p2<p1)  break;//如果队列为空且没有剩余的工作就退出
	}
	for(int i=1;i<=n;i++)
		printf("%lld ",ans[i]);
	return 0;
}
```
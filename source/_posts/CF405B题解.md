---
title: CF405B题解
date: 2024-08-02 20:24:13
tags: 题解
---

# CF405B（模拟）

## 题目大意：

给出 $N$ 个多米诺骨牌，同时推动一些骨牌，求最后有多少个骨牌保持竖立。

## 思路分析：

我们可以分情况讨论骨牌竖立的情况。

1. 骨牌左右都没有倒下的骨牌。
2. 骨牌左右倒下的骨牌数量相等。

我们可以从左往右扫一遍，记录前面有多少个骨牌没有被推动。

如果当前骨牌也没有被推动，那么我们把计数器加一；

如果当前骨牌被推动了，那么我们再分情况讨论：

1. 当前骨牌向右推动，前面的骨牌没有倒下时，我们把答案直接加上计数器；

2. 当前骨牌向左推动，前面有骨牌向右推动，那么我们判断计数器是否为奇数，如果是就把答案加一；

3. 对于其他情况，都不会影响答案。

按照这样的方式扫一遍就可以得到答案。

**注意：如果最后的几个骨牌没有被推动，仍然需要记算答案。**

## 完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=3005;
int n,d[N],ans,dir,cnt;
int main(){
	char c;
	scanf("%d\n",&n);
	for(int i=1;i<=n;i++){
		scanf("%c",&c);
		if(c=='L')  d[i]=-1;//-1表示向左推，1表示向右推
		if(c=='R')  d[i]=1;
	}
	dir=-1;
	for(int i=1;i<=n;i++){
		if(d[i]==0)  cnt++;//第一种情况
		else if(d[i]==-1&&dir==1)  ans+=cnt%2;//第二种情况
		else if(d[i]==1&&dir==-1)  ans+=cnt;//第三种情况
		if(d[i]!=0)  cnt=0,dir=d[i];
	}
	if(dir==-1)  ans+=cnt;
	printf("%d",ans);
	return 0;
}
```

